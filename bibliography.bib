
@inproceedings{gibbons_phases_2023,
	location = {Seattle {WA} {USA}},
	title = {Phases in Software Architecture},
	isbn = {9798400702976},
	url = {https://dl.acm.org/doi/10.1145/3609025.3609479},
	doi = {10.1145/3609025.3609479},
	abstract = {The large-scale structure of executing a computation can often be thought of as being separated into distinct phases. But the most natural form in which to specify that computation may well have a different and conflicting structure. For example, the computation might consist of gathering data from some locations, processing it, then distributing the results back to the same locations; it may be executed in three phases—gather, process, distribute—but mostly conveniently specified orthogonally—by location. We have recently shown that this multi-phase structure can be expressed as a novel applicative functor (also known as an idiom, or lax monoidal functor). Here we summarize the idea from the perspective of software architecture. At the end, we speculate about applications to choreography and multi-tier architecture.},
	eventtitle = {{FUNARCH} '23: 1st {ACM} {SIGPLAN} International Workshop on Functional Software Architecture},
	pages = {29--33},
	booktitle = {Proceedings of the 1st {ACM} {SIGPLAN} International Workshop on Functional Software Architecture},
	publisher = {{ACM}},
	author = {Gibbons, Jeremy and Kidney, Donnacha Oisín and Schrijvers, Tom and Wu, Nicolas},
	urldate = {2023-10-02},
	date = {2023-08-30},
	langid = {english},
}

@inproceedings{minamide_functional_1998,
	location = {New York, {NY}, {USA}},
	title = {A functional representation of data structures with a hole},
	isbn = {978-0-89791-979-1},
	url = {https://doi.org/10.1145/268946.268953},
	doi = {10.1145/268946.268953},
	series = {{POPL} '98},
	abstract = {Data structures with a hole, in other words data structures with an uninitialized field, are useful to write efficient programs: they enable us to construct functional data structures flexibly and write functions such as append and map as tail recursive functions. In this paper we present an approach to introducing data structures with a hole into call-by-value functional programming languages like {ML}. Data structures with a hole are formalized as a new form of λ-abstraction called hole abstraction. The novel features of hole abstraction are that expressions inside hole abstraction are evaluated and application is implemented by destructive update of a hole. We present a simply typed call-by-value λ-calculus extended with hole abstractions. Then we show a compilation method of hole abstraction and prove correctness of the compilation.},
	pages = {75--84},
	booktitle = {Proceedings of the 25th {ACM} {SIGPLAN}-{SIGACT} symposium on Principles of programming languages},
	publisher = {Association for Computing Machinery},
	author = {Minamide, Yasuhiko},
	urldate = {2022-03-15},
	date = {1998-01-21},
}


@inproceedings{yang_efficient_2015,
	location = {Vancouver {BC} Canada},
	title = {Efficient communication and collection with compact normal forms},
	isbn = {978-1-4503-3669-7},
	url = {https://dl.acm.org/doi/10.1145/2784731.2784735},
	doi = {10.1145/2784731.2784735},
	abstract = {In distributed applications, the transmission of non-contiguous data structures is greatly slowed down by the need to serialize them into a buffer before sending. We describe Compact Normal Forms, an {API} that allows programmers to explicitly place immutable heap objects into regions, which can both be accessed like ordinary data as well as efﬁciently transmitted over the network. The process of placing objects into compact regions (essentially a copy) is faster than any serializer and can be amortized over a series of functional updates to the data structure in question. We implement this scheme in the Glasgow Haskell Compiler and show that even with the space expansion attendant with memory-oriented data structure representations, we achieve between ×2 and ×4 speedups on fast local networks with sufﬁciently large data structures.},
	eventtitle = {{ICFP}'15: 20th {ACM} {SIGPLAN} International Conference on Functional Programming},
	pages = {362--374},
	booktitle = {Proceedings of the 20th {ACM} {SIGPLAN} International Conference on Functional Programming},
	publisher = {{ACM}},
	author = {Yang, Edward Z. and Campagna, Giovanni and Ağacan, Ömer S. and El-Hassany, Ahmed and Kulkarni, Abhishek and Newton, Ryan R.},
	urldate = {2022-04-04},
	date = {2015-08-29},
	langid = {english},
	keywords = {serialization, memory, compact-regions},
	file = {Yang et al. - 2015 - Efficient communication and collection with compac.pdf:/home/thomas/Zotero/storage/ZKBJILPD/Yang et al. - 2015 - Efficient communication and collection with compac.pdf:application/pdf},
}

@techreport{jones_gibbons_linearbfs_93,
  title = "Linear-time Breadth-first Tree Algorithms: An Exercise in the Arithmetic of Folds and Zips",
  author = "Geraint Jones and Jeremy Gibbons",
  year = "1993",
  institution = "Dept of Computer Science, University of Auckland",
  month = "may",
  note = "Also IFIP Working Group 2.1 working paper 705~WIN-2",
  number = "No.\,71",
  url = "http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/linear.ps.gz",
}


@inproceedings{okasaki_bfs_2000,
	location = {New York, {NY}, {USA}},
	title = {Breadth-first numbering: lessons from a small exercise in algorithm design},
	isbn = {978-1-58113-202-1},
	url = {https://dl.acm.org/doi/10.1145/351240.351253},
	doi = {10.1145/351240.351253},
	series = {{ICFP} '00},
	shorttitle = {Breadth-first numbering},
	abstract = {Every programmer has blind spots. Breadth-first numbering is an interesting toy problem that exposes a blind spot common to many---perhaps most---functional programmers.},
	pages = {131--136},
	booktitle = {Proceedings of the fifth {ACM} {SIGPLAN} international conference on Functional programming},
	publisher = {Association for Computing Machinery},
	author = {Okasaki, Chris},
	urldate = {2023-10-12},
	date = {2000-09-01},
	keywords = {Breadth-first numbering, breadth-first traversal, views},
}


@incollection{girard_linear_1995,
	location = {Cambridge},
	title = {Linear Logic: its syntax and semantics},
	isbn = {978-0-511-62915-0},
	url = {https://www.cambridge.org/core/product/identifier/CBO9780511629150A008/type/book_part},
	shorttitle = {Linear Logic},
	pages = {1--42},
	booktitle = {Advances in Linear Logic},
	publisher = {Cambridge University Press},
	author = {Girard, J.-Y.},
	editor = {Girard, Jean-Yves and Lafont, Yves and Regnier, Laurent},
	urldate = {2022-03-21},
	date = {1995},
	langid = {english},
	doi = {10.1017/CBO9780511629150.002},
	keywords = {linear, logic},
}


@article{bernardy_linear_2018,
	title = {Linear Haskell: practical linearity in a higher-order polymorphic language},
	volume = {2},
	issn = {2475-1421},
	url = {http://arxiv.org/abs/1710.09756},
	doi = {10.1145/3158093},
	shorttitle = {Linear Haskell},
	abstract = {Linear type systems have a long and storied history, but not a clear path forward to integrate with existing languages such as {OCaml} or Haskell. In this paper, we study a linear type system designed with two crucial properties in mind: backwards-compatibility and code reuse across linear and non-linear users of a library. Only then can the benefits of linear types permeate conventional functional programming. Rather than bifurcate types into linear and non-linear counterparts, we instead attach linearity to function arrows. Linear functions can receive inputs from linearly-bound values, but can also operate over unrestricted, regular values. To demonstrate the efficacy of our linear type system - both how easy it can be integrated in an existing language implementation and how streamlined it makes it to write programs with linear types - we implemented our type system in {GHC}, the leading Haskell compiler, and demonstrate two kinds of applications of linear types: mutable data with pure interfaces; and enforcing protocols in I/O-performing functions.},
	pages = {1--29},
	issue = {{POPL}},
	journaltitle = {Proceedings of the {ACM} on Programming Languages},
	shortjournal = {Proc. {ACM} Program. Lang.},
	author = {Bernardy, Jean-Philippe and Boespflug, Mathieu and Newton, Ryan R. and Jones, Simon Peyton and Spiwack, Arnaud},
	urldate = {2022-06-23},
	date = {2018-01},
	eprinttype = {arxiv},
	eprint = {1710.09756 [cs]},
	keywords = {Computer Science - Programming Languages},
	file = {arXiv Fulltext PDF:/home/thomas/Zotero/storage/KYWAMVVH/Bernardy et al. - 2018 - Linear Haskell practical linearity in a higher-or.pdf:application/pdf;arXiv.org Snapshot:/home/thomas/Zotero/storage/WC3FP8CN/1710.html:text/html},
}
